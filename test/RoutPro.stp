{ -- Program pro RoutPro ver. 1.4 , realizujici protokol A343c -- }
// Upravy :
//-----------------------------------------------------------------------
// 16.12.04 - otaci se hodnota dat v intervalu <100,200> na <200,100>
//
// Tato direktiva urcuje konfiguraci automatu, pro kterou je program urcen
//(na zaklade teto direktivy dojde k optimalnimu nastaveni adresy programu a dat)
#Configuration "ROUTPRO"

#pragma $LJ
#databegin 1024
//NetAddr(0) 

var
	// Promenne vazici se k RS232
	I0  # RxBuffer  : array[31] of word;
	O0  # TxBuffer  : array[15] of word;
	O16 # TxPointer : word;
	O17 # RxPointer : word;
	O18 # BaudRate  : word;
	Y7  # GapMode	: bit;

	// Promenne vazici se k RS485
	MessCount	:	word;		// Pocitadlo doslych zprav
	MsgErrCount:	word;		// Pocitadlo doslych zprav z chybnym CRC nebo nespravnym obsahem ramce 
	
	RxChar		:	word;
	FramePos	:	word;		// Poradi znaku v ramci 0=hlavicka
	PesnetCode	:	word;		// Predpripraveny SenCode
	FrameCRC	:	word;		// Vypoctena hodnota CRC prijimaneho ramce (cely word)
	AnswerCRC	:	word;		// Vypoctena hodnota CRC odesilaneho ramce (cely word)
	FrameLen	:	word;		// Delka celeho ramce odpovedi na funkce 1 az 4
	TimeOutErr	:	word;		// Pocitadlo chyb na strane PesNetu (Vyprseni Time Outu na opoved z PesNetu)
	PesNetCount:	word;		// Pocitadlo pozadavku odeslanych do pesnetu
	T0	# TimeOutCount:	word;	// Citac TimeOutu pro prijem odpovedi z PesNetu
	
	RxFrame		:	bit;		// Probiha prijimani ModBus ramce 
	FrameErr	:	bit;		// Chyba v prijimu ModBus ramce 
	PesNetRQ	:	bit;		// Indikator vyslani pozadavku do PesNetu	
	AnswerFrame:	bit;		// Priznak zahajeni vysilani odpovedi na funkce cteni
	
	Operation	:	word;		// Typ operace (R,W,A)
	MotorNbr	:	word;		// Cislo motorku v modulu (0-31)
	ModulNbr	:	word;		// Cislo modulu	(0-3)
	PosValue	:	word;		// Hodnota pro polohu motoru
	FrameData	:	array [8] of word;	// pole pro ulozeni hodnot poloh z/do framu
	BufferPtr	:	word;
	PesStillProgress : bit;		// Priznak, ze se provadi operace na PESNetu
	SendFinished : bit;			// Priznak, ukonceni odeslani zacatku zpravy pri odpovedi na cteni bloku
end

const
	1 # Bd2400;
	2 # Bd4800;
	3 # Bd9600;
	4 # Bd19200;
	5 # Bd38400;
	6 # Bd57600;
	7 # Bd115200;
	// Konstanty k RS485
	0 # Ready;
	1 # WriteXBit;
	3 # WriteXbyte;
	4 # ReadXbyte;
	5 # WriteXword;
	6 # ReadXword;
	0 # Break;
	//-------------------
	5 # PesNetTimeOut;			// Maximalni doba cekani na odezvu z PesNetu (v desitkach milisekund) 

	// Konstanty k protokolu
	//
	6  # ACK;
	21 # NAK;
	13 # CR;
	24 # CAN;
	10 # LF;
	'@'# HEAD;
	54 # NAK_CRC;
	// Typ operace
	'R' #	ReadMotor;
	'W' #	WriteMotor;
	'A' #	ReadModul;
	'X' #	WriteModul;
	// Poloha pole s hodnotami polohy motorku
	1152 # DefPosBegin;	
	1218 # RealPosBegin;	
end


// Inkrementuje cislo typu word
procedure Inc(var cislo:word)
	cislo = cislo + 1;
return

// Pripocitava CRC soucet 
function CRCCount(CRC,InpData:word):word;
 	if InpData = CR or InpData = LF then
 		CRCCount = CRC;
 	else
 		CRCCount = CRC^InpData
 	endif
return

// Inicializace po restartu
procedure GlogalInit 
	BaudRate = Bd9600;
	GapMode';
	MessCount = 0;
	MsgErrCount = 0;
	TimeOutErr = 0;
	RxFrame';
	FramePos = 0x0FFFF;
	PesNetCount = 0;
	PesNetRQ';
	AnswerFrame';
	TimeOutCount=0; TEN0; TPA0';
	T1=0; TEN1; TPA1';
	Turbo';
return

//------------------------------------------------------------------------
//     Zpracovani jednotlivych znaku v prichozim ramci z RS232

// Zpracovani 1. bytu zpravy - kod operace (R,A,W)
Procedure GetOperation
	// typ operace
	Operation = RxChar;
	case RxChar
		of ReadMotor	then 	
			PesNetCode = ReadXWord;
		of WriteMotor	then
			PesNetCode = WriteXWord;
     	of ReadModul	then
			PesNetCode = ReadXWord;
     	of WriteModul	then
			PesNetCode = WriteXWord;
     	else  
			FrameErr;
	endcase
return	

// Zpracovani 2. bytu zpravy - cislo barevniku (0 - 31)
procedure GetStationNbr
	// Cislo barevniku(cilove stanice), musi byt 0~30 a nesmi se schodovat  s  adresou  RoutPro.
	if RxChar > 130 or  RxChar < 100 then
		FrameErr;
	else
		SendCode = Break;
		SendAddr = RxChar-100;
	endif
return

// Zpracovani 3. bytu zpravy - cislo modulu, nebo motorku (dle operace)
procedure GetMotSec
	var begin : word; end
	
	if Operation = ReadMotor or Operation = ReadModul then
		begin = RealPosBegin;
	elseif Operation = WriteMotor or Operation = WriteModul then
		begin = DefPosBegin;
	endif
	
	RxChar = RxChar - 100;
	if Operation = ReadMotor or Operation = WriteMotor then
		if RxChar >= 0 and RxChar <= 32 then
			MotorNbr = RxChar;
			MemAddr = begin +  MotorNbr*2;
		else
			FrameErr;
		endif
	elseif Operation = ReadModul or Operation = WriteModul then
		if RxChar >= 0 and RxChar <= 3 then
			ModulNbr = RxChar;
			MemAddr = begin + ModulNbr*16;
		else
			FrameErr;
		endif
	else
		FrameErr;
	endif
return

Procedure RxComplet
	RxFrame';
	RxPointer = 0; 
	Inc(MessCount);
	if FrameCRC <> 0 then FrameErr; endif
	if FrameErr' then
		AnswerCRC = 0;
		PesNetRQ;									// Byla vyslana zprava do PesNetu a ocekava se odpoved
		PesStillProgress;
		if SendAddr<>MyAddr then SendCode = PesnetCode; endif
		TimeOutCount=0;							    // Vynulovani pocitadla timeoutu
		Inc(PesNetCount);
		if Operation = WriteModul then BufferPtr = 1; else BufferPtr = 0; endif
	else
		Inc(MsgErrCount);
	endif 
return

procedure GetCRC
	if Operation = ReadMotor or Operation = ReadModul then
		if FramePos >= 4 and FramePos <= 7 then
			if FramePos = 4	and RxChar <> '#' then FrameErr; endif
			// 5. znak se ignoruje (uz je zpracovan)
			if FramePos = 6	and RxChar <> CR then FrameErr; endif
			if FramePos = 7	then 
				if RxChar = LF then RxComplet; else FrameErr; endif
			endif
		else 
			FrameErr;
		endif
	elseif Operation = WriteMotor then
		if FramePos >= 6 and FramePos <= 9 then
			if FramePos = 6	and RxChar <> '#' then FrameErr; endif
			// 7. znak se ignoruje (uz je zpracovan)
			if FramePos = 8	and RxChar <> CR then FrameErr; endif
			if FramePos = 9	then 
				if RxChar = LF then RxComplet; else FrameErr; endif
			endif
		else
			FrameErr;
		endif
	elseif Operation = WriteModul then
		if FramePos >= 13 and FramePos <= 16 then
			if FramePos = 13 and RxChar <> '#' then FrameErr; endif
			// 14. znak se ignoruje (uz je zpracovan)
			if FramePos = 15 and RxChar <> CR then FrameErr; endif
			if FramePos = 16 then 
				if RxChar = LF then RxComplet; else FrameErr; endif
			endif
		else
			FrameErr;
		endif
	else
		FrameErr;
	endif
return

//------------------------------------------------------------------------
//     Sestaveni odpovedi na ramce z RS232

// Sestaveni ramce pro odeslani odpovedi o chybnem prijmu a jeji odeslani
procedure SendErrorAnswer
	TxBuffer[5] = HEAD;
	TxBuffer[4] = NAK;
	TxBuffer[3] = '#';
	TxBuffer[2] = NAK_CRC;
	TxBuffer[1] = CR;
	TxBuffer[0] = LF;
	TxPointer=6;				// Odeslani odpovedi
return

// odeslani zacatku odpovedi na ReadModul
procedure SendSHead
	TxBuffer[4] = HEAD;
	TxBuffer[3] = 'S'; AnswerCRC = CRCCount(AnswerCRC, 'S');
	TxBuffer[2] = SendAddr + 100; AnswerCRC = CRCCount(AnswerCRC, SendAddr + 100);
	TxBuffer[1] = ModulNbr + 100; AnswerCRC = CRCCount(AnswerCRC, ModulNbr + 100);
	TxBuffer[0] = ';'; AnswerCRC = CRCCount(AnswerCRC, ';');
	TxPointer = 5; // odeslu zacatek zpravy
return

// Odeslani odpovedi na WriteMotor
procedure SendWriteOKAnsw
	TxBuffer[5] = HEAD;
	TxBuffer[4] = ACK;
	TxBuffer[3] = '#'
	TxBuffer[2] = 37
	TxBuffer[1] = CR
	TxBuffer[0] = LF
	TxPointer=6;				// Odeslani odpovedi
return

// Odeslani odpovedi "stanice neodpovida"
procedure SendNoStation
	TxBuffer[5] = HEAD;
	TxBuffer[4] = CAN;
	TxBuffer[3] = '#'
	TxBuffer[2] = 59
	TxBuffer[1] = CR
	TxBuffer[0] = LF
	TxPointer=6;				// Odeslani odpovedi
return

// Otaci hodnotu dat v intervalu <100,200> na <200,100>
function ReverseData(data : word):word;
	if data >= 100 and data <= 200 then
		ReverseData = 200 - data;
	else
		ReverseData = data;
	endif
return

// Odeslani odpovedi na ReadMotor 
procedure SendReadMotorAnsw
	TxBuffer[9] = HEAD;
	TxBuffer[8] = 'D'; AnswerCRC = CRCCount(AnswerCRC, 'D');
	TxBuffer[7] = SendAddr + 100; AnswerCRC = CRCCount(AnswerCRC, SendAddr + 100);
	TxBuffer[6] = MotorNbr + 100; AnswerCRC = CRCCount(AnswerCRC, MotorNbr + 100);
	TxBuffer[5] = ';'; AnswerCRC = CRCCount(AnswerCRC, ';');
	TxBuffer[4] = ReverseData(SendData+ 100); AnswerCRC = CRCCount(AnswerCRC, ReverseData(SendData + 100));
	TxBuffer[3] = '#'; AnswerCRC = CRCCount(AnswerCRC, '#');
	TxBuffer[2] = AnswerCRC;
	TxBuffer[1] = CR
	TxBuffer[0] = LF
	TxPointer=10;				// Odeslani odpovedi
return

// Zpracovani a odeslani odpovedi na ReadModul
procedure SendReadModulAnsw
	if PesStillProgress then
		if BufferPtr >= 0 and BufferPtr <= 7 then
			FrameData[BufferPtr] = ReverseData(SendData + 100); 
			//AnswerCRC = CRCCount(AnswerCRC, SendData + 100);
			MemAddr = MemAddr + 2; // posun na dalsi polozku
			Inc(BufferPtr);
			SendCode = PesNetCode;
			TimeOutCount=0;							    // Vynulovani pocitadla timeoutu
		else // vyslu zacatek odpovedi(cela se mi do TxBufferu nevejde:()
			SendSHead;
			PesStillProgress';
			SendFinished';
			BufferPtr = 0;
		endif
	else
		// musim pockat, nez se zacatek odpovedi odesle
		TimeOutCount=0;							    // Musim vynulovani pocitadla timeoutu
		if SendFinished' then 
			if TxPointer = 0 then SendFinished; endif
		else									
			if BufferPtr < 8 then // ted muzu naplnit zbytek
				PosValue = FrameData[BufferPtr];
				TxBuffer[11 - BufferPtr] = PosValue; 
				AnswerCRC = CRCCount(AnswerCRC, PosValue);
				Inc(BufferPtr);
			else // a odeslat						
				PesNetRq';
				TxBuffer[3] = '#'; AnswerCRC = CRCCount(AnswerCRC, '#');
				TxBuffer[2] = AnswerCRC;
				TxBuffer[1] = CR
				TxBuffer[0] = LF
				TxPointer = 12;				// Odeslani odpovedi
			endif
		endif
	endif
return

// Zpracovani a odeslani odpovedi na WriteModul
procedure SendWriteModulAnsw
	if PesStillProgress then
		if BufferPtr >= 1 and BufferPtr <= 7 then
			SendData = FrameData[BufferPtr]; 
			SendCode = PesNetCode;
			MemAddr = MemAddr + 2; // posun na dalsi polozku
			Inc(BufferPtr);
			TimeOutCount=0;							    // Vynulovani pocitadla timeoutu
		else // vyslu odpoved
			SendWriteOKAnsw
			PesStillProgress';
			PesNetRq';
		endif
	endif
return


//************************************************************************
//*                                                                      *
//*                    HLAVNI PROGRAMOVA SMYCKA                          *
//*                                                                      *
//************************************************************************

if reset then GlogalInit; reset'; endif

//------------------------------------------------------------------------
//        PRIJEM A DEKODOVANI RAMCU Z RS232                             
//------------------------------------------------------------------------
if RxPointer>0 and PesNetRq' then 

	// zachyceni hlavicky ramce
	if RxFrame' then
		if RxBuffer[0] = HEAD then
			FramePos = 1; RxFrame; FrameErr'; FrameCRC = 0; PesStillProgress';
		else
			RxPointer = 0;
		endif
	endif
 
 	// zachyceni ostatnich znaku ramce
	if RxFrame and FramePos<RxPointer then
		RxChar = RxBuffer[FramePos] & 255;
		FrameCRC = CRCCount(FrameCRC, RxChar);					// Vypocet CRC 
		case FramePos
			of 1 then GetOperation;
			of 2 then GetStationNbr;
			of 3 then GetMotSec;
		endcase  
		if FramePos >= 4 then
			case Operation
				of ReadMotor	then	
					GetCRC;
				of WriteMotor	then	
					if FramePos = 4 and RxChar <> ';' then FrameErr; endif
					if FramePos = 5 then SendData = ReverseData(RxChar) - 100;
					elseif FramePos > 5 then GetCRC; 
					endif
				of ReadModul	then
					GetCRC;
				of WriteModul	then
					if FramePos = 4 and RxChar <> ';' then FrameErr; endif
					if FramePos >= 5 and FramePos <= 12 then 
						FrameData[FramePos - 5] = ReverseData(RxChar) - 100;
						if FramePos = 5 then SendData = ReverseData(RxChar) - 100; endif
					elseif FramePos > 12 then GetCRC; 
					endif					
				else
					FrameErr;
			endcase
		endif
		Inc(FramePos);
		// reakce na chybu v ramci
		if FrameErr then 
			RxFrame'; RxPointer = 0;
			SendErrorAnswer;
		endif
	endif
endif

//-------------------------------------------------------------------------
//                REAKCE NA ZPRAVU Z RS232
//-------------------------------------------------------------------------
if PesNetRq then
	if SendCode<>Ready then
		// Vyprsel TimeOut prijmu dat z PesNetu
		if TimeOutCount>PesNetTimeOut then SendCode=Break; PesNetRq'; Inc(TimeOutErr); SendNoStation; endif
	else
		if Operation = WriteMotor then
			PesNetRq';
			SendWriteOKAnsw;
		elseif Operation = ReadMotor then
			PesNetRq';
			SendReadMotorAnsw;
		elseif Operation = ReadModul then
			SendReadModulAnsw;
		elseif Operation = WriteModul then
			SendWriteModulAnsw;
		endif
	endif
endif

end
